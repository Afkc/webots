#VRML_SIM R2023b utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# A cutomizable lockable door.
# template language: javascript

EXTERNPROTO "GenericDoorAppearance.proto"
EXTERNPROTO "webots://projects/appearances/protos/Roughcast.proto"
EXTERNPROTO "webots://projects/appearances/protos/VarnishedPine.proto"
EXTERNPROTO "DoorLever.proto"
EXTERNPROTO "webots://projects/objects/solids/protos/SolidBox.proto"
EXTERNPROTO "webots://projects/objects/geometries/protos/TexturedBox.proto"

PROTO DoorWithLock [
  field SFVec3f    translation            0 0 0
  field SFRotation rotation               0 0 1 0
  field SFString   name                   "door"
  field SFVec3f    size                   0.2 1 2.4                 # Defines the width, height and thickness of the door wall frame.
  field SFBool     canBeOpen              TRUE                      # Defines whether the door is connected to the frame throught a hinge-joint.
  field SFFloat    position               0                         # Defines the position (aperture) of the door.
  field SFBool     jointAtLeft            TRUE                      # Defines on which side the door is connected to the frame.
  field SFBool     selfClosing            FALSE                     # Defines whether the door as a spring effect that makes it closing on itself.
  field SFFloat    doorThickness          0.05                      # Defines the thickness of the door.
  field SFFloat    frameHeight            2.0                       # Defines the height of the door frame. It should be must be less than or equal to `size.y`.
  field SFVec3f    frameSize              0.05 0.05 0.05            # Defines the size of the door frame.
  field SFFloat    spaceUnderDoor         0.012                     # Defines the size between the door and the floor.
  field SFFloat    mainMaterialDensity    200                       # Defines the density of the door.
  field SFNode     doorAppearance         GenericDoorAppearance {}  # Defines the door's appearance.
  field SFNode     wallAppearance         Roughcast {}              # Defines the wall's appearance.
  field SFNode     frameAppearance        VarnishedPine {}          # Defines the frame's appearance.
  field SFNode     doorHandle             DoorLever { canTurn TRUE }              # Defines an optional door handle.
  field MFNode     doorSlot               []                        # Extends the door with new nodes.
  field SFBool     castShadows            TRUE                      # Defines whether this object should cast shadows.
]
{
  %<
    let size = fields.size.value;
    if (size.x <= 0 || size.y <= 0 || size.z <= 0) {
      size = fields.size.defaultValue;
      console.error('\'size\' must be strictly positive. Value reset to (' + size.x + ', ' + size.y + ', ' + size.z + ').');
    }

    let doorThickness = fields.doorThickness.value;
    if (doorThickness <= 0.0) {
      doorThickness = fields.doorThickness.defaultValue;
      console.error('\'doorThickness\' must be strictly positive. Value reset to ' + doorThickness + '.');
    }

    let spaceUnderDoor = fields.spaceUnderDoor.value;
    if (spaceUnderDoor <= 0.0) {
      spaceUnderDoor = fields.spaceUnderDoor.defaultValue;
      console.error('\'spaceUnderDoor\' must be strictly positive. Value reset to ' + spaceUnderDoor + '.');
    }

    let frameHeight = fields.frameHeight.value;
    if (frameHeight <= 0.0) {
      frameHeight = fields.frameHeight.defaultValue;
      console.error('\'frameHeight\' must be strictly positive. Value reset to ' + frameHeight + '.');
    } else if (frameHeight > size.z) {
      frameHeight = size.z;
      console.error('\'frameHeight\' must be less than or equal to \'size.z\'. Value reset to ' + frameHeight + '.');
    }

    let frameSize = fields.frameSize.value;
    if (frameSize.x <= 0 || frameSize.y <= 0 || frameSize.z <= 0) {
      frameSize = fields.frameSize.defaultValue;
      console.error('\'frameSize\' must be strictly positive. Value reset to (' + frameSize.x + ', ' + frameSize.y + ', ' + frameSize.z + ').');
    } else if (frameSize.x < doorThickness / 4) {
      frameSize = fields.frameSize.defaultValue;
      console.error('\'frameSize.x\' must be at least doorThickness / 4. Value reset to (' + frameSize.x + ', ' + frameSize.y + ', ' + frameSize.z + ').');
    } else if (frameSize.y < 0.01) {
      frameSize = fields.frameSize.defaultValue;
      console.error('\'frameSize.y\' must be at least frameSize.y. Value reset to (' + frameSize.x + ', ' + frameSize.y + ', ' + frameSize.z + ').');
    }

    let handle = fields.doorHandle.value;
    if (handle !== undefined) {
      if (handle.fields.jointAtLeft !== undefined && fields.jointAtLeft.value !== handle.fields.jointAtLeft.value)
        console.error('\'jointAtLeft\' field value of Door and doorHandle nodes does not match.');

      if (handle.fields.hasStaticParent !== undefined && handle.fields.hasStaticParent.value === fields.canBeOpen.value)
        console.error('\'doorHandle.hasStaticParent\' value is incorrect, the parent Door object is static.');
    }

    let mirrorFactor = fields.jointAtLeft.value ? -1 : 1;
  >%
  Solid {
    translation IS translation
    rotation IS rotation
    children [
      %<
       const topWallHeight = size.z - frameHeight;
       if (topWallHeight > 0) {
      >%
        Solid {
          translation 0 0 %<= size.z - 0.5 * topWallHeight >%
          children [
            Shape {
              appearance IS wallAppearance
              geometry Box {
                size %<= size.x >% %<= size.y >% %<= topWallHeight >%
              }
              castShadows IS castShadows
            }
          ]
          name "mobile part"
          boundingObject Box {
            size %<= size.x >% %<= size.y >% %<= topWallHeight >%
          }
        }
      %< } >%
      SolidBox { # top frame
        translation 0 0 %<= frameHeight - 0.5 * frameSize.z >%
        name "top frame"
        size %<= 2 * frameSize.x + size.x >% %<= size.y - 2 * frameSize.y >% %<= frameSize.z >%
        appearance IS frameAppearance
        castShadows IS castShadows
      }
      SolidBox { # left frame
        translation 0 %<= -0.5 * size.y + 0.5 * frameSize.y >% %<= 0.5 * frameHeight >%
        name "left frame"
        size %<= 2 * frameSize.x + size.x >% %<= frameSize.y >% %<= frameHeight >%
        appearance IS frameAppearance
        castShadows IS castShadows
      }
      Solid { # right frame
        translation 0 %<= 0.5 * size.y - 0.5 * frameSize.y >% %<= 0.5 * frameHeight >%
        name "right frame"
        children [
          Shape {
            appearance IS frameAppearance
            geometry Box {
              size %<= 2 * frameSize.x + size.x >% %<= frameSize.y >% %<= frameHeight >%
            }
            castShadows IS castShadows
          }
          Connector {
            rotation 0 0 1 3.1415926535
            translation %<= frameSize.x + size.x / 2 - doorThickness / 4 + 0.001 >% %<= - frameSize.y / 2 + 0.005 >% 0.02
            autoLock TRUE
            isLocked TRUE
            model "door lock"
            shearStrength 10
          }
        ]
        boundingObject Group {
          children [
            Transform {
              translation %<= - doorThickness / 4 >% 0 0
              children [
                Box {
                  size %<= 2 * frameSize.x + size.x  - doorThickness / 2 >% %<= frameSize.y >% %<= frameHeight >%
                }
              ]
            }
            Transform {
              translation %<= frameSize.x + size.x / 2 - doorThickness / 8 + 0.0005 >% 0 0
              children [
                Box {
                  size %<= doorThickness / 4 - 0.001 >% %<= frameSize.y >% %<= frameHeight >%
                }
              ]
            }
          ]
        }
      }
      %< if (fields.canBeOpen.value) { >%
        HingeJoint {
          jointParameters HingeJointParameters {
            position IS position
            anchor %<= 0.5 * size.x + frameSize.x >% %<= mirrorFactor * (0.5 * size.y - frameSize.y) >% %<= 0.5 * frameHeight >%
            axis 0 0 1
            %< if (mirrorFactor > 0) { >%
              minStop 0
              maxStop 1.57
            %< } else { >%
              minStop -1.57
              maxStop 0
            %< } >%
            %< if (fields.selfClosing.value) { >%
              springConstant 5
            %< } >%
            dampingConstant 10
          }
          endPoint
      %< } >%
          Solid {
            children [
              Transform { # door
                translation %<= 0.5 * size.x + frameSize.x + 0.25 * doorThickness >% 0.005 %<= 0.5 * (frameHeight - frameSize.z) + spaceUnderDoor >%
                children [
                  Shape {
                    appearance IS doorAppearance
                    geometry TexturedBox { # texture is mirrored on the back face of the door
                      size %<= doorThickness / 2 >% %<= size.y - 2 * frameSize.y + 0.01 >% %<= frameHeight - frameSize.z - spaceUnderDoor>%
                    }
                    castShadows IS castShadows
                  }
                ]
              }
              Transform { # door (part with the lock)
                translation %<= 0.5 * size.x + frameSize.x - 0.25 * doorThickness >% 0 %<= 0.5 * (frameHeight - frameSize.z) + spaceUnderDoor>%
                children [
                  Shape {
                    appearance IS doorAppearance
                    geometry TexturedBox { # texture is mirrored on the back face of the door
                      size %<= doorThickness / 2 >% %<= size.y - 2 * frameSize.y >% %<= frameHeight - frameSize.z - spaceUnderDoor>%
                    }
                    castShadows IS castShadows
                  }
                ]
              }
              Transform { # handle
                translation %<= 0.5 * size.x + frameSize.x >% %<= - mirrorFactor * ((size.y - 2 * frameSize.y) / 2 - 0.05) >% %<= 0.5 * frameHeight >%
                children [
                  Slot {
                    type "door handle"
                    endPoint IS doorHandle
                  }
                ]
              }
              Transform {
                translation %<= 0.5 * size.x + frameSize.x + 0.5 * doorThickness >% 0 %<= 0.5 * frameHeight >%
                children IS doorSlot
              }
            ]
            boundingObject Group {
              children [
                Transform {
                  translation %<= 0.5 * size.x + frameSize.x + 0.25 * doorThickness >% 0.005 %<= 0.5 * (frameHeight - frameSize.z) + spaceUnderDoor >%
                  children [
                    Box {
                      size %<= doorThickness / 2 >% %<= size.y - 2 * frameSize.y + 0.01 >% %<= frameHeight - frameSize.z - spaceUnderDoor>%
                    }
                  ]
                }
                Transform {
                  translation %<= 0.5 * size.x + frameSize.x - 0.25 * doorThickness >% 0 %<= 0.5 * (frameHeight - frameSize.z) + spaceUnderDoor>%
                  children [
                    Box {
                      size %<= doorThickness / 2 >% %<= size.y - 2 * frameSize.y >% %<= frameHeight - frameSize.z - spaceUnderDoor>%
                    }
                  ]
                }
              ]
            }
            %< if (fields.canBeOpen.value) { >%
              physics Physics {
                density IS mainMaterialDensity
              }
            %< } >%
          }
      %< if (fields.canBeOpen.value) { >%
        }
      %< } >%
    ]
    name IS name
    model "door"
  }
}
